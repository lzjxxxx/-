C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE control
OBJECT MODULE PLACED IN .\Out_File\control.obj
COMPILER INVOKED BY: D:\c251\C251\BIN\C251.EXE control.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..
                    -\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\US
                    -ER\src;..\MDK;.\MY_LIBRARY) DEBUG PRINT(.\Out_File\control.lst) OBJECT(.\Out_File\control.obj) 

stmt  level    source

    1          #include "control.h"
    2          #define kp_motor 100
    3          #define ki_motor 50
    4          #define kd_motor 0.1
    5          #define kp_servo 8
    6          #define ki_servo 4
    7          #define kd_servo 0.1
    8          #define L_Max   3795
    9          #define L_Min   700
   10          #define R_Max   3780
   11          #define R_Min   740
   12          #define LM_Max  3780
   13          #define LM_Min  725
   14          #define RM_Max  3800
   15          #define RM_Min  80
   16          #define circle_duty_flag 1200
   17          #define ramp_threshold 160
   18          float error;
   19          float A,MyB,C,MyP;
   20          float L,R,LM,RM;
   21          extern int16 diangan[4];
   22          float SpeedNowL;
   23          float SpeedNowR;
   24          float AdcNow = 0;
   25          uint16 TofNow = 0;
   26          const int8 sqrtTable[26] = {
   27              0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5
   28          };
   29          int8 fastSqrt(int8 x)
   30          {
   31   1          if (x<=0)
   32   1          {
   33   2              x = fabs(x); 
   34   2              if ( x >= 25) 
   35   2              {
   36   3                  x = 25;  // ´¦Àí³¬³ö·¶Î§µÄÇé¿ö
   37   3              }
   38   2              return (-sqrtTable[x]);
   39   2          }
   40   1          else
   41   1          {
   42   2              if ( x >= 25) 
   43   2              {
   44   3                  x = 25;  // ´¦Àí³¬³ö·¶Î§µÄÇé¿ö
   45   3              }
   46   2              return (sqrtTable[x]);
   47   2          }
   48   1          
   49   1          
   50   1      }
   51          float fabs(float x)
   52          {
   53   1          if(x<0)
   54   1          {
   55   2              x = -x;
   56   2          }
   57   1          return x;
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 2   

   58   1      }
   59          void SpeedComputerL(int32 EncodeNow, uint8 isrms)
   60          {
   61   1          uint8 i = 0, j = 0;
   62   1          int16 templ = 0.0;
   63   1          static uint8 SpCount = 0, k = 0;
   64   1          static int16 SpeedArryL[10] = {0.0};
   65   1          if (SpCount == isrms)
   66   1          {
   67   2      
   68   2              SpeedArryL[k++] = (float)(EncodeNow);
   69   2              if(k == 10)
   70   2              {
   71   3                  for (i = 10; i >= 1; i--)
   72   3                  {
   73   4                      for(j = 0; j< (i-1); j++)
   74   4                      {
   75   5                          if (SpeedArryL[j] > SpeedArryL[j+1])
   76   5                          {
   77   6                              templ = SpeedArryL[j];
   78   6                              SpeedArryL[j] = SpeedArryL[j+1];
   79   6                              SpeedArryL[j+1] = templ;
   80   6                          
   81   6                          }
   82   5                      }
   83   4                     
   84   4                  }
   85   3                  templ = 0;
   86   3                  for (i = 2;i < 8; i++)
   87   3                  {
   88   4                      templ += SpeedArryL[i];
   89   4                  }
   90   3                  templ = templ/6;
   91   3                  //Ò»½×µÍÍ¨ÂË²¨
   92   3                  /*Y(n) = q*X(n) + (1-q)*Y(n-1)
   93   3                  qÂË²¨ÏµÊý(0-1)   X(n)±¾´Î²ÉÑùÖµ   Y(n-1)ÉÏ´ÎÂË²¨Êä³öÖµ
   94   3                  qÔ½´ó£¬´ïµ½Ä¿±êÖµµÄËÙ¶ÈÔ½¿ì£¬µ«ÊÇÇúÏß²»Æ½»¬£¬qÔ½Ð¡ÇúÏßÔò»áÔ½Æ½»¬£¬µ«ÊÇÏìÓ¦Ô½Âý*/
   95   3                  SpeedNowL = (float)(((float)0.7 * templ) + (SpeedNowL * (float)0.3));
   96   3                  k = 0;
   97   3              }
   98   2                  SpCount = 0;
   99   2          }
  100   1          SpCount++; 
  101   1      }
  102          
  103          void SpeedComputerR(int32 EncodeNow, uint8 isrms)
  104          {
  105   1          
  106   1          uint8 i = 0, j = 0;
  107   1          int16 tempr = 0.0;
  108   1          static uint8 SpCount = 0, k = 0;
  109   1          static int16 SpeedArryR[10] = {0.0};
  110   1          
  111   1          if (SpCount == isrms)
  112   1          {
  113   2      
  114   2              SpeedArryR[k++] = (float)(EncodeNow);
  115   2              SpeedArryR[k++] = EncodeNow;
  116   2              if(k == 10)
  117   2              {
  118   3                  for (i = 10; i > 1; i--)
  119   3                  {
  120   4                      for(j = 0; j< (i-1); j++)
  121   4                      {
  122   5                          if (SpeedArryR[j] > SpeedArryR[j+1])
  123   5                          {
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 3   

  124   6                              tempr = SpeedArryR[j];
  125   6                              SpeedArryR[j] = SpeedArryR[j+1];
  126   6                              SpeedArryR[j+1] = tempr;
  127   6                          
  128   6                          }
  129   5                      }
  130   4                     
  131   4                  }
  132   3                  tempr = 0;
  133   3                  for (i = 2;i < 8; i++)
  134   3                  {
  135   4                      tempr += SpeedArryR[i];
  136   4                  }
  137   3                  tempr = tempr/6;
  138   3                  //Ò»½×µÍÍ¨ÂË²¨
  139   3                  /*Y(n) = q*X(n) + (1-q)*Y(n-1)
  140   3                  qÂË²¨ÏµÊý(0-1)   X(n)±¾´Î²ÉÑùÖµ   Y(n-1)ÉÏ´ÎÂË²¨Êä³öÖµ
  141   3                  qÔ½´ó£¬´ïµ½Ä¿±êÖµµÄËÙ¶ÈÔ½¿ì£¬µ«ÊÇÇúÏß²»Æ½»¬£¬qÔ½Ð¡ÇúÏßÔò»áÔ½Æ½»¬£¬µ«ÊÇÏìÓ¦Ô½Âý*/
  142   3                  SpeedNowR = (float)(((float)0.7 * tempr) + (SpeedNowR * (float)0.3));
  143   3                  k = 0;
  144   3              }
  145   2                  SpCount = 0;
  146   2          }
  147   1          SpCount++;
  148   1      }
  149          float direction()
  150          {
  151   1          //Ôö´óA / B A/BA/B½«ÔöÇ¿LRÁ½¸öµç¸ÐµÄ×÷ÓÃ£¬Ôö´óB / C B/CB/C½«Ìá¸ß³µ¡°ÇÐÍäµÀÇãÏò¡±£¬¸ÃÖµÔ½´ó£¬¾­¹ýÍäµÀÊ
             -±³µ½«¸üÌù½ü°¼ÏÝ²à¡£
  152   1          A = 1;
  153   1          MyB = 1;
  154   1          C = 1;
  155   1          //MyP = 6;
  156   1          MyP = 10;
  157   1          AdcRead();
  158   1          L = (float)diangan[0];
  159   1          
  160   1          R = (float)diangan[3];
  161   1          LM = (float)diangan[1];
  162   1          RM = (float)diangan[2];
  163   1      //    L = ((float)diangan[0]/(float)(L_Max))*100;
  164   1      //    
  165   1      //    R = ((float)diangan[3]/(float)(R_Max))*100;
  166   1      //    LM = ((float)diangan[1]/(float)(LM_Max))*100;
  167   1      //    RM = ((float)diangan[2]/(float)(RM_Max))*100;
  168   1          error = ((A*(L-R)+MyB*(LM-RM))/(A*(L+R)+fabs(C*(LM-RM))))*MyP;//²îºÍ±È¼ÆËã³öÆ«²î
  169   1      //    if (error<0)error = -(error*error);
  170   1      //    else error = error*error;
  171   1          return error;
  172   1      }
  173          float direction_cir()
  174          {
  175   1          A = 1;
  176   1          MyB = 1;
  177   1          C = 1;
  178   1          MyP = 10.0;
  179   1          AdcRead();
  180   1          LM = (float)diangan[1];
  181   1          RM = (float)diangan[2];
  182   1      //    LM = ((float)diangan[1]/(float)(LM_Max-LM_Min))*100;
  183   1      //    RM = ((float)diangan[2]/(float)(RM_Max-RM_Min))*100;
  184   1          error = (MyB*(LM-RM))/(C*(LM+RM))*MyP;//²îºÍ±È¼ÆËã³öÆ«²î
  185   1          //error = (L-R)/(L+R)*10.0;//Õâ¸öÖµÊ¼ÖÕÐ¡ÓÚ1
  186   1              //ÏÞ·ù
  187   1          return error;
  188   1      }
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 4   

  189          
  190          float direction_cross()
  191          {
  192   1          A = 1;
  193   1          MyB = 0.75;
  194   1          C = 1;
  195   1          MyP = 10.0;
  196   1          AdcRead();
  197   1          L = (float)diangan[0];
  198   1          R = (float)diangan[3];
  199   1          error = (L-R)/(L+R)*10.0;//Õâ¸öÖµÊ¼ÖÕÐ¡ÓÚ1
  200   1          
  201   1          return error;
  202   1      }
  203          void ComputerADC(float error, uint8 isrms)
  204          {
  205   1          uint8 i = 0;
  206   1          int16 tempadc = 0;
  207   1          static uint8 SpCount = 0, k = 0;
  208   1          int16 min = 0;
  209   1          int16 max = 0;
  210   1          static int16 AdcArry[10] = {0.0};
  211   1          if (SpCount == isrms)
  212   1          {
  213   2              AdcArry[k++] = error;
  214   2              if(k == 10)
  215   2              {
  216   3                  for (i = 0; i < 10; i++)
  217   3                  {
  218   4                      if(AdcArry[i]>max)
  219   4                      {
  220   5                          max = AdcArry[i];
  221   5                      }
  222   4                      if(AdcArry[i]<min)
  223   4                      {
  224   5                          min = AdcArry[i];
  225   5                      }
  226   4                      tempadc += AdcArry[i];
  227   4                     
  228   4                  }
  229   3                   tempadc = tempadc - max -min;
  230   3                   AdcNow = (int16)(tempadc/8);
  231   3              }
  232   2              SpCount = 0;
  233   2          }     
  234   1          SpCount++; 
  235   1      }
  236          //¶æ»úÐÞÕý
  237          void ServoCorrection(int32 error)
  238          {
  239   1      
  240   1          ServoControl(error);
  241   1      }
  242          
  243          float  servo_error[2] = {0};
  244          float  servo_kp;
  245          float  servo_kd;
  246          int16  servo_duty_delta;
  247          void PidControlServo()//´«ÈëÄ¿±ê½Ç¶ÈÓëÊµ¼Ê½Ç¶È
  248          {
  249   1          ComputerADC(direction(), 1);//´«ÈëµÄÎó²îÎªfloatÀàÐÍ
  250   1      //    servo_kp = 15;
  251   1      //    servo_kd = 0;
  252   1      //    if(fabs(AdcNow)<=1.5)
  253   1      //    {
  254   1      //       servo_kp = 1;
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 5   

  255   1      //       servo_kd = 10;
  256   1      //    }
  257   1          if((fabs(AdcNow)<=3.5))
  258   1          {
  259   2             servo_kp = 7.5;
  260   2             servo_kd = 3;
  261   2          }
  262   1          else if((fabs(AdcNow)>3.5)&&(fabs(AdcNow)<=5.5))
  263   1          {
  264   2             servo_kp = 7.5+(fabs(AdcNow)-3.5)*1;//×î´ó10
  265   2             servo_kd = 4;
  266   2          }
  267   1          else if((fabs(AdcNow)>5.5)&&(fabs(AdcNow)<=8.5))
  268   1          {
  269   2             servo_kp = 9.5+(fabs(AdcNow)-5.5)*1;//×î´ó12
  270   2             servo_kd = 5;
  271   2          }
  272   1          else if(fabs(AdcNow)>8.5)
  273   1          {
  274   2             servo_kp = 10;
  275   2             servo_kd = 6;
  276   2          }
  277   1          servo_error[0] = AdcNow;    //²î±ÈºÍ´úÈëÎó²î×÷Îª·´À¡
  278   1          if (servo_error[0]>= 100)
  279   1          {
  280   2              servo_error[0] = 100;
  281   2          
  282   2          }
  283   1          else if(servo_error[0] <= -100)
  284   1          {
  285   2          
  286   2              servo_error[0] = -100;
  287   2          }
  288   1          servo_duty_delta = (servo_error[0]*servo_kp + (servo_error[0]-servo_error[1])*servo_kd);    //¶æ»úÎ»Ö
             -ÃÊ½PDÔËËã
  289   1          //servo_duty_delta /= 1.8;    //¿É¸ù¾ÝÇé¿ö·ÅËõÊýÖµ´óÐ¡£¬×¢Òâ±ðÒç³ö¾ÍÐÐ
  290   1          servo_error[1] = servo_error[0];    //Îó²î´¢´æ
  291   1          ServoControl(servo_duty_delta);    //Ö´ÐÐ¶æ»úPWMÊä³ö
  292   1      }
  293          float  speed_error_L[2] = {0};
  294          float  speed_error_R[2] = {0};
  295          float  motor_kp_L = 1.65;
  296          float  motor_kp_R = 1.5;
  297          float  motor_ki_L = 0;
  298          float  motor_ki_R = 0;
  299          uint16  motor_duty_L ;
  300          uint16  motor_duty_R ;
  301          uint16 speed_set_L;
  302          uint16 speed_set_R;
  303          extern uint8 circle_return;
  304          void PID_motor(uint16 speed_set, float speed_now_L, float speed_now_R)
  305          {
  306   1      //    if( (circle_return == 1)||(circle_return == 3))
  307   1      //    {
  308   1      //        speed_set_L = speed_set;    //Ä¿±êËÙ¶È£¬Éæ¼°²îËÙ¿É×ÔÐÐ°´¹«Ê½ÐÞ¸Ä
  309   1      //        speed_set_R = speed_set;
  310   1          //}
  311   1      //    speed_set_L = speed_set;    //Ä¿±êËÙ¶È£¬Éæ¼°²îËÙ¿É×ÔÐÐ°´¹«Ê½ÐÞ¸Ä
  312   1      //        speed_set_R = speed_set;
  313   1          speed_set_L = speed_set+((uint16)direction())*10;    //Ä¿±êËÙ¶È£¬Éæ¼°²îËÙ¿É×ÔÐÐ°´¹«Ê½ÐÞ¸Ä
  314   1          speed_set_R = speed_set-((uint16)direction())*10;
  315   1          speed_error_L[0] = (float)(speed_set_L - speed_now_L);    //ËÙ¶ÈÆ«²î¼ÆËã
  316   1          speed_error_R[0] = (float)(speed_set_R - speed_now_R);
  317   1          motor_duty_L += (uint16)(motor_kp_L * (speed_error_L[0]-speed_error_L[1]) + motor_ki_L * speed_error_
             -L[0] );    //µç»úÔöÁ¿Ê½PIÔËËã£¬PI»ù±¾¾Í¹»ÁË£¬¼ÓDÒ²¿ÉÒÔ
  318   1          motor_duty_R += (uint16)(motor_kp_R * (speed_error_R[0]-speed_error_R[1]) + motor_ki_R * speed_error_
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 6   

             -R[0] );
  319   1          speed_error_L[1] = speed_error_L[0];    //Îó²î´¢´æ
  320   1          speed_error_R[1] = speed_error_R[0];
  321   1          MotorControlL(motor_duty_L);    //Ö´ÐÐµç»úPWMÊä³ö
  322   1          MotorControlR(motor_duty_R);
  323   1      }
  324          uint8 circle_ready()//Ô¤Èë»·
  325          {
  326   1          if(L>=3800)
  327   1          {
  328   2              return 1;
  329   2          }
  330   1          else
  331   1          {
  332   2              return 0;
  333   2          }
  334   1      }
  335          
  336          int circle_judge()
  337          {
  338   1          uint8 circle_Flag = 0;
  339   1          if((L>=3500)&&((L-LM)>=1600))//ÖÐ
  340   1          {
  341   2              circle_Flag = 1;
  342   2              
  343   2          }
  344   1      //    else if((LM/RM) >= 50&&(LM>=1000))//ÓÒÆ«
  345   1      //    {
  346   1      //        circle_Flag = 1;
  347   1      //    }
  348   1      //    else if((LM>=3000)&&(RM>=2000)&&(R>=2400))//×óÆ«
  349   1      //    {
  350   1      //        circle_Flag = 1;
  351   1      //    }
  352   1          return circle_Flag;
  353   1      
  354   1      }
  355          
  356          float  servo_kp_cir = 25;
  357          float  servo_kd_cir = 0 ;
  358          void circle_control()
  359          {
  360   1          //AdcRead();
  361   1          ComputerADC(direction_cir(), 1);//´«ÈëµÄÎó²îÎªfloatÀàÐÍ
  362   1          servo_error[0] = AdcNow;    //²î±ÈºÍ´úÈëÎó²î×÷Îª·´À¡
  363   1          if (servo_error[0]>= 100)
  364   1          {
  365   2              servo_error[0] = 100;
  366   2          
  367   2          }
  368   1          else if(servo_error[0] <= -100)
  369   1          {
  370   2          
  371   2              servo_error[0] = -100;
  372   2          }
  373   1          servo_duty_delta = (servo_error[0]*servo_kp_cir + (servo_error[0]-servo_error[1])*servo_kd_cir);    /
             -/¶æ»úÎ»ÖÃÊ½PDÔËËã
  374   1          //servo_duty_delta /= 2;    //¿É¸ù¾ÝÇé¿ö·ÅËõÊýÖµ´óÐ¡£¬×¢Òâ±ðÒç³ö¾ÍÐÐ
  375   1          servo_error[1] = servo_error[0];    //Îó²î´¢´æ
  376   1          ServoControl(servo_duty_delta);    //Ö´ÐÐ¶æ»úPWMÊä³ö
  377   1      }
  378          int cross_judge()
  379          {
  380   1          if((L/R<=1.8)&&(R/L<=1.8)&&(L>=2500||R>=2500))
  381   1      //    if(((L/R<=1.8)&&(R/L<=1.8)&&(RM/LM<=1.8)&&(LM/RM)<=1.8)||((LM>=3300)&&(RM>=3300)&&(L+R)>=4500))
  382   1          {
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 7   

  383   2              return 1;
  384   2          }
  385   1          else
  386   1          {
  387   2              return 0;
  388   2          }
  389   1      }
  390          
  391          float  servo_kp_cro = 1;
  392          float  servo_kd_cro = 0 ;
  393          void cross_control()
  394          {
  395   1          ComputerADC(direction_cross(), 1);//´«ÈëµÄÎó²îÎªfloatÀàÐÍ
  396   1          servo_error[0] = AdcNow;    //²î±ÈºÍ´úÈëÎó²î×÷Îª·´À¡
  397   1          if (servo_error[0]>= 100)
  398   1          {
  399   2              servo_error[0] = 100;
  400   2          
  401   2          }
  402   1          else if(servo_error[0] <= -100)
  403   1          {
  404   2          
  405   2              servo_error[0] = -100;
  406   2          }
  407   1          servo_duty_delta = (servo_error[0]*servo_kp_cir + (servo_error[0]-servo_error[1])*servo_kd_cir);    /
             -/¶æ»úÎ»ÖÃÊ½PDÔËËã
  408   1          servo_error[1] = servo_error[0];    //Îó²î´¢´æ
  409   1          ServoControl(servo_duty_delta);    //Ö´ÐÐ¶æ»úPWMÊä³ö
  410   1      }
  411          
  412          /*tof²â¾à*/
  413          void tof_get(uint16 dl1a_distance_mm)
  414          {
  415   1          uint8 i = 0;
  416   1          uint16 temptof = 0;
  417   1          static uint8 SpCount = 0, k = 0;
  418   1          uint16 min = 0;
  419   1          uint16 max = 0;
  420   1          static uint16 TofArry[10] = {0.0};
  421   1          TofArry[k++] = dl1a_distance_mm;
  422   1          if(k == 10)
  423   1          {
  424   2              for (i = 0; i < 10; i++)
  425   2              {
  426   3                  if(TofArry[i]>max)
  427   3                  {
  428   4                      max = TofArry[i];
  429   4                  }
  430   3                  if(TofArry[i]<min)
  431   3                  {
  432   4                     min = TofArry[i];
  433   4                  }
  434   3                  temptof += TofArry[i];
  435   3                     
  436   3              }
  437   2              temptof = temptof - max -min;
  438   2              TofNow =  (uint16)(temptof/8);
  439   2          }      
  440   1      }
  441          uint8 ramp_flag;
  442          uint8 ramp_judge(dl1a_distance_mm)
  443          {
  444   1          
  445   1          if((dl1a_distance_mm<=ramp_threshold)&&(RM<=1000)&&(LM<=1000)&&(R<=1000)&&(LM>=300)&&(R>=200))
  446   1          {
  447   2              ramp_flag = 1;
C251 COMPILER V5.60.0,  control                                                            19/07/23  21:09:12  PAGE 8   

  448   2              
  449   2          }
  450   1          else
  451   1          {
  452   2              ramp_flag = 0;
  453   2          }
  454   1          return ramp_flag;
  455   1      
  456   1      }
  457          float  servo_kp_ramp = 15;
  458          float  servo_kd_ramp = 0 ;
  459          
  460          void ramp_control()
  461          {
  462   1          ComputerADC(direction(), 1);
  463   1          servo_error[0] = AdcNow;    
  464   1          if (servo_error[0]>= 100)
  465   1          {
  466   2              servo_error[0] = 100;
  467   2          
  468   2          }
  469   1          else if(servo_error[0] <= -100)
  470   1          {
  471   2          
  472   2              servo_error[0] = -100;
  473   2          }
  474   1          servo_duty_delta = (servo_error[0]*servo_kp_ramp + (servo_error[0]-servo_error[1])*servo_kd_ramp);   
             - //¶æ»úÎ»ÖÃÊ½PDÔËËã
  475   1          //servo_duty_delta /= 2;    //¿É¸ù¾ÝÇé¿ö·ÅËõÊýÖµ´óÐ¡£¬×¢Òâ±ðÒç³ö¾ÍÐÐ
  476   1          servo_error[1] = servo_error[0];    //Îó²î´¢´æ
  477   1          ServoControl(servo_duty_delta);    //Ö´ÐÐ¶æ»úPWMÊä³ö
  478   1      }    


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3355     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       282     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       292     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
